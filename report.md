# Отчет по лабораторной работе №1

## Цель работы

Получить общее представление о системе команд RISC-V путем написания программы суммирования положительных элементов в матрице (вариант 3).

## Реализация на ассемблере RISC-V

Код программы:

```
.data
N:
  .word 6
M:
  .word 3
matrix:
  .word 1, -2, -3, -4, -5, -6
  .word 1, -2, -3, -4, -5, -6
  .word 1, -2, -3, -4, -5, -6
result:
  .word 0

.text

.globl _start

_start:
  call main

  addi a0, x0, 10
  ecall

main:
  addi sp, sp, -16 # Сохраняем место в стеке с выравниванием 16 бит
  sw ra, 12(sp)    # Сохраняем значение регистра ra - адреса возврата,
                   # так как main вызывает другие функции
  lw a0, N
  lw a1, M
  la a2, matrix
  la a3, result    # Загрузка аргументов в соответствующие регистры
  call sum_pos     # sum_pos( N, M, *matrix, *result)

  lw a1, result
  call print_int

  lw ra, 12(sp)   # Возвращаем сохраненный адрес возврата
  addi sp, sp, 16 # освобождаем место на стеке
  ret

print_int:
  addi a0, x0, 1
  ecall
  ret

sum_pos:
  addi t1, x0, 0 # Очищаем регистр t1, так как в нем могут быть неактуальные данные
  mv t2, a0      # Копируем значение a0 в t2 (инициализация счетчика цикла)
  cycle_0:
    lw t0, 0(a2)   # Получаем значение по адресу a2 в регистр t0 (первый элемент в матрице)
    addi a2, a2, 4 # a2 += 4 (Сместили указатель на следующий элемент матрицы)
    blt t0, x0, loop_check_row # Проверка знака элемента 
    add t1, t1, t0 # Если элемент положительный, то прибавляем его к результату
  loop_check_row:
    addi t2, t2, -1     # }
    bgt t2, x0, cycle_0 # } for (t2 = a0; t2 > 0; t2--) cycle_0
  loop_check_col:
    addi a1, a1, -1     # }
    ble a1, x0, fun_end # } for (a1 = M; a1 > 0; a1--)
    mv t2, a0           # Восстановление значения t2 = N
    j cycle_0           # Возврат в начало цикла
  fun_end:
    sw t1, 0(a3)        # *result = t1
    ret
```

Реализация на ассемблере разбита на две секции `.data` для хранения переменных и `.text` для хранения кода программы. При исполнении данной программы на устройстве, эти две секции сохранились бы в разные участки памяти, адреса которых были бы указаны в файле-линковщика.

Всего в программе есть 4 подпрограммы:
- `_start` - начало исполнения программы и выход из нее, вызывает главную функцию `main`.
- `main` - главная функция подпрограммы, содержит в себе вызов функции с реализацией алгоритма и вывод результата.
- `sum_pos` - реализация алгоритма суммирования положительных элементов матрицы.
- `print_int` - вывод числа в консоль.

### Функция `main`

Данная функция начинает работу с выделения места на стеке и сохранения на стек значения регистра `ra` - адреса возврата. Это нужно для того, чтобы при вызове внутри `main` другой функции не потерять текущее значение регистра `ra`. При выходе из функции происходит обратный процесс.

<div align="center">

| Начало `main`                          | Завершение `main`                       |
|----------------------------------------|-----------------------------------------|
| <pre>addi sp, sp, -16<br>sw ra, 12(sp) </pre> | <pre>lw ra, 12(sp)<br>addi sp, sp, 16 </pre> |

</div>

Вызов функции алгоритма сопровождается загрузкой четырех параметров в регистры `a0-a3`. Туда загружаются количество строк, количество столбцов, ссылка на первый элемент матрицы и ссылка на результат.

### Функция `sum_pos`

Функция реализующая алгоритм суммирования положительных элементов. Функция начинается с инициализации временных регистров, которые будут использоваться во время работы функции. Данная функция не сохраняет значение регистра `ra`, потому что она не вызывает другие функции, и значения регистров `s*`, потому что она не использует эти регистры.

Алгоритм работы представлен вложенным циклом, в котором построчно проверяются и суммируются элементы матрицы.

Работа программы проверена в симуляторе `Venus`, результат работы представлен на рисункe 1.

<div align="center">

| ![res1](../res1.png)  |
|:-:|
| Рис. 1 - Результат работы  |

</div>

На этом рисунке представлены выходные данные - таблица под меткой `.matrix`, вывод программы в консоль, а также состояние памяти, где хранится значение результата по адресу `0x10000004`.

## Программа на C

```c
#include <stdio.h>

#define N 6
#define M 3

void sum_pos(int n, int m, int matrix[M][N], int* res) {
  for (size_t i = 0; i < m; i++) {
    for (size_t j = 0; j < n; j++) {
      if (matrix[i][j] > 0) {
        *res += matrix[i][j];
      }
    }
  }
}

int main() {
  int matrix[M][N] = {0};
  int result = 0;

  for (size_t i = 0; i < M; i++) {
    for (size_t j = 0; j < N; j++) {
      scanf("%d", &matrix[i][j]);
    }
  }

  sum_pos(N, M, matrix, &result);

  printf("%d\n", result);
}
```

В данную программу матрица подается поэлементно через ввод в консоль после чего вызывается функция, вычисляющая сумму положительных элементов в матрице.

Для сборки и получения дампа программы написан `Makefile`.

## Анализ dump-файла

Сразу бросается в глаза большой размер полученного файла по сравнению с написанной программой. Это связаноо с тем, что в этот файл входят функции, которые были подключены с помощью `#include`, а также большой блок отладочной информации.

Сравнение вызова функции

|Dump-файл|Моя реализация|
|---------|--------------|
|<pre>mv	a3,a4<br>mv	a2,a5<br>li	a1,3<br>li	a0,6<br>jal	ra,10140 <sum_pos> </pre>|<pre>lw a0, N<br>lw a1, M<br>la a2, matrix<br>la a3, result<br>call sum_pos</pre>|

Вызов функции, которая рассчитывает сумму положительных элементов матрицы похож за исключением того, что ссылки на матрицу и на результат копируются из других регистров, а не загружаются напрямую. Также отличается сам вызов, я использую псевдоинструкцию `call`, которая транслируется во вариант полученный компилятором.

Следующее отличие заключается в использовании переданных аргументов функцией. Моя реализация использует аргументы сразу из регистров, в которых они были переданы или копирует их в временные регистры `t*`. Скомпилированная программа сохраняет переданные аргументы в стеке. Кроме этого, перед сохранением аргументов в стек, функция выделяет место на стеке и записывает вершину стека в регистр `s0`, относительно которого происходят операции со стеком.

```
  10140:	fd010113          	addi	sp,sp,-48
  10144:	02812623          	sw	s0,44(sp)
  10148:	03010413          	addi	s0,sp,48
  1014c:	fca42e23          	sw	a0,-36(s0)
  10150:	fcb42c23          	sw	a1,-40(s0)
  10154:	fcc42a23          	sw	a2,-44(s0)
  10158:	fcd42823          	sw	a3,-48(s0)
  1015c:	fe042623          	sw	zero,-20(s0)
```

Получение нового элемента из матрицы и проверка его на положительность:

```
  10184:	fd442783          	lw	a5,-44(s0) # загрузили адрес элемента
  10188:	00e78733          	add	a4,a5,a4   # Скопировали адрес в a4
  1018c:	fe842783          	lw	a5,-24(s0) # Загрузили счетчик в a5
  10190:	00279793          	slli	a5,a5,0x2 # a5 *= 4
  10194:	00f707b3          	add	a5,a4,a5   # a5 += a4
  10198:	0007a783          	lw	a5,0(a5)   # загрузили значение элемента в а5
  1019c:	04f05463          	blez	a5,101e4 <sum_pos+0xa4> # а5 <= 0
```

Прибавление элемента к результату:

```
  101c8:	fe842783          	lw	a5,-24(s0)  # Загрузка счетчика в a5
  101cc:	00279793          	slli	a5,a5,0x2
  101d0:	00f707b3          	add	a5,a4,a5    # Расчет адреса элемента на основе значения счетчика
  101d4:	0007a783          	lw	a5,0(a5)
  101d8:	00f68733          	add	a4,a3,a5    # Сложение промежуточного результата в a4
  101dc:	fd042783          	lw	a5,-48(s0)
  101e0:	00e7a023          	sw	a4,0(a5)    # Сохранение промежуточного результата в стек
```

### Основные моменты

1. Каждая подпрограмма сохраняет переданные аргументы в стек и работает с ними через стек
2. Для хранения промежуточных результатов используются регистры `a*`, а не `t*`.
3. Подпрограммы минимизируют использование различных регистров, что приводит к частым обращениям к стеку
